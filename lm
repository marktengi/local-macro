#!/bin/zsh

help() {
    cat <<EOF
Usage:
  lm <macro-name> <args...>
    Runs the macro with the given name and arguments.
  lm [-l | --list]
    Lists all macros in the current directory and parent directories.
  lm [-h | --help]
    Shows this help message.
  lm [-r | --resolve] <macro-name>
    Recursively resolves the given macro name to the script path.
EOF
}

# Configuration:
#   LM_DIR_NAME - The name of the directory containing the macro scripts.
#     Default: .local-macro

# Environment variables:
#   LM_CALL_DIR - The path to the directory from which `lm` was called.
#   LM_MACRO_DIR - The path to the parent of the resolved script's `.local-macro` directory.
#   LM_MACRO - The name of the macro.

# set -x

MACRO_DIR_NAME="${LM_DIR_NAME:-.local-macro}"

resolve() {
    local macro_name=$1
    local current_dir=$(pwd)
    # recursively look for `$MACRO_DIR_NAME/$macro_name`
    while true; do
        # check if the file exists and is executable
        if [ -x "$current_dir/$MACRO_DIR_NAME/$macro_name" ]; then
            echo "$current_dir/$MACRO_DIR_NAME/$macro_name"
            return 0
        fi
        if [ "$current_dir" = "/" ]; then
            break
        fi
        current_dir=$(dirname $current_dir)
    done
    return 1
}

list_macros() {
    local current_dir=$(pwd)
    local seen_names=()
    while true; do
        if [ -d "$current_dir/$MACRO_DIR_NAME" ]; then
            for macro_name in $(ls -1 "$current_dir/$MACRO_DIR_NAME"); do
                # skip if not executable
                if [ ! -x "$current_dir/$MACRO_DIR_NAME/$macro_name" ]; then
                    continue
                fi
                if ! [[ "${seen_names[@]}" =~ "$macro_name" ]]; then
                    echo "$macro_name (from $current_dir)"
                    seen_names+=($macro_name)
                else
                    echo "[!] $macro_name (from $current_dir)"
                fi
            done
        fi
        if [ "$current_dir" = "/" ]; then
            break
        fi
        current_dir=$(dirname $current_dir)
    done
}

call_macro() {
    local macro_path=$1
    shift
    local call_dir=$(pwd)
    local macro_dir=$(dirname $(dirname $macro_path))
    local macro_name=$(basename $macro_path)
    echo "calling $macro_name from $macro_dir" >&2
    env LM_CALL_DIR="$call_dir" LM_MACRO_DIR="$macro_dir" LM_MACRO="$macro_name" $macro_path "$@"
    return $?
}   

main() {
    case $1 in
        -l | --list)
            list_macros
            return 0
            ;;
        -h | --help)
            help
            return 0
            ;;
        -r | --resolve)
            if [ -z "$2" ]; then
                echo "Macro name is required"
                return 1
            fi
            resolve $2
            return $?
            ;;
        *)
            if [ -z "$1" ]; then
                list_macros
                return 0
            fi
            ;;
    esac

    local marco_path=$(resolve $1)
    if [ -z "$marco_path" ]; then
        echo "Macro not found: $1"
        return 1
    fi
    shift
    call_macro $marco_path "$@"
}

main "$@"