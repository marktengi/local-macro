#!/bin/bash

help() {
    cat <<EOF
Usage:
  lm | lm [-l | --list]
    Lists all macros in the current directory and parent directories.
  lm macro-name [args...]
    Runs the macro with the given name and arguments.
  lm [-c | --create] macro-name
    Creates a new macro with the given name in the current directory.
  lm [-r | --resolve] macro-name
    Recursively resolves the given macro name to the script path.
  lm [-h | --help]
    Shows this help message.
  lm --completion
    Prints a completion script for the current shell that can be sourced to enable tab completion.
EOF
}

# Configuration:
#   LM_DIR_NAME - The name of the directory containing the macro scripts.
#     Default: .local-macro

# Environment variables:
#   LM_CALL_DIR - The path to the directory from which `lm` was called.
#   LM_MACRO_DIR - The path to the parent of the resolved script's `.local-macro` directory.
#   LM_MACRO - The name of the macro.

MACRO_DIR_NAME="${LM_DIR_NAME:-.local-macro}"

resolve() {
    local macro_name=$1
    local current_dir
    current_dir=$(pwd)
    # recursively look for `$MACRO_DIR_NAME/$macro_name`
    while true; do
        # check if the file exists and is executable
        if [ -x "$current_dir/$MACRO_DIR_NAME/$macro_name" ]; then
            echo "$current_dir/$MACRO_DIR_NAME/$macro_name"
            return 0
        fi
        if [ "$current_dir" = "/" ]; then
            break
        fi
        current_dir=$(dirname "$current_dir")
    done
    return 1
}

# TODO combine with resolve, or at least factor out the recursive search logic
list_macros() {
    local current_dir
    current_dir=$(pwd)
    local seen_names=()
    while true; do
        if [ -d "$current_dir/$MACRO_DIR_NAME" ]; then
            # this will skip over hidden files, but running `lm .hidden-macro` will run a macro named `.hidden-macro` if it exists
            for macro_path in "$current_dir/$MACRO_DIR_NAME"/*; do
                [[ -e "$macro_path" ]] || break
                macro_name=$(basename "$macro_path")
                if [ ! -x "$macro_path" ]; then
                    echo "[!] $macro_name (from $current_dir) is not executable"
                    continue
                fi
                # this will probably break if the macro name contains a space but why would you do that??
                if ! [[ "${seen_names[*]}" == *"$macro_name"* ]]; then
                    echo "    $macro_name (from $current_dir)"
                    seen_names+=("$macro_path")
                else
                    echo "[!] $macro_name (from $current_dir) is shadowed"
                fi
            done
        fi
        if [ "$current_dir" = "/" ]; then
            break
        fi
        current_dir=$(dirname "$current_dir")
    done
    if [ ${#seen_names[@]} -eq 0 ]; then
        echo "No macros found"
    fi
}

call_macro() {
    local macro_path=$1
    shift
    local call_dir
    call_dir=$(pwd)
    local macro_dir
    macro_dir=$(dirname "$(dirname "$macro_path")")
    local macro_name
    macro_name=$(basename "$macro_path")
    echo "calling $macro_name from $macro_dir" >&2
    env LM_CALL_DIR="$call_dir" LM_MACRO_DIR="$macro_dir" LM_MACRO="$macro_name" "$macro_path" "$@"
    return $?
}

ensure_macro_dir() {
    if [ ! -d "$MACRO_DIR_NAME" ]; then
        echo "Creating macro directory $MACRO_DIR_NAME in $(pwd)" >&2
        mkdir "$MACRO_DIR_NAME"
    fi
}

create_macro() {
    ensure_macro_dir

    local macro_name=$1
    local macro_path="$MACRO_DIR_NAME/$macro_name"

    touch "$macro_path"
    chmod +x "$macro_path"
    echo "Macro $macro_name created at $macro_path"
    if [ -n "$EDITOR" ]; then
        $EDITOR "$macro_path"
    fi
}

print_completion() {
    if [ "$1" == "zsh" ]; then
        _print_completion_zsh
        return 0
    # elif [ -n "$BASH" ]; then
    #     _print_completion_bash
    #     return 0
    else
        echo "Unsupported shell"
        return 1
    fi
}

# TODO add ability to complete shell name after --completion, macro name after -r
_print_completion_zsh() {
    cat <<EOF
# run this with: source <(lm --completion zsh)
_lm_completion() {
    local operations macros ret=1

    operations=(
        + '(operation)' \
        {-l,--list}'[list macros]:->operation' \
        {-c,--create}'[create a new macro]:->operation' \
        {-r,--resolve}'[resolve the location of a macro with the given name]' \
        --completion'[print completion script]:->operation'\
        {-h,--help}'[show help]:->operation'
    )

    if [ "\$STATE" != 'operation' ]; then
        macros=\$(list_macros)
        if [ -n "\$macros" ]; then
            macros=\$(echo "\$macros" | grep -v '[!]' | sed 's/ *\([^ ]\+\) (\(.*\))/\1\\:"\2"/')

            operations+=( + '(macro)' :macro:"((\$macros))" )
        fi
    fi

    _arguments -A "-*" "\${operations[@]}" && ret=0

    return \$ret
}

compdef _lm_completion lm
EOF
}

main() {
    case $1 in
        -l | --list)
            list_macros
            return 0
            ;;
        -r | --resolve)
            if [ -z "$2" ]; then
                echo "Macro name is required"
                return 1
            fi
            resolve "$2"
            return $?
            ;;
        -c | --create)
            if [ -z "$2" ]; then
                echo "Macro name is required"
                return 1
            fi
            create_macro "$2"
            return $?
            ;;
        -h | --help)
            help
            return 0
            ;;
        --completion)
            print_completion "$2"
            return 0
            ;;
        *)
            if [ -z "$1" ]; then
                list_macros
                return 0
            fi
            ;;
    esac

    local macro_path
    macro_path=$(resolve "$1")
    if [ -z "$macro_path" ]; then
        echo "Macro not found: $1"
        return 1
    fi
    shift
    call_macro "$macro_path" "$@"
}

main "$@"