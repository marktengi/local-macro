#!/bin/bash

help() {
    cat <<EOF
Usage:
  lm macro-name [args...]
    Runs the macro with the given name and arguments.
  lm [-c | --create] macro-name
    Creates a new macro with the given name in the current directory.
  lm [-l | --list]
    Lists all macros in the current directory and parent directories.
  lm [-r | --resolve] macro-name
    Recursively resolves the given macro name to the script path.
  lm [-h | --help]
    Shows this help message.
EOF
}

# Configuration:
#   LM_DIR_NAME - The name of the directory containing the macro scripts.
#     Default: .local-macro

# Environment variables:
#   LM_CALL_DIR - The path to the directory from which `lm` was called.
#   LM_MACRO_DIR - The path to the parent of the resolved script's `.local-macro` directory.
#   LM_MACRO - The name of the macro.

MACRO_DIR_NAME="${LM_DIR_NAME:-.local-macro}"

resolve() {
    local macro_name=$1
    local current_dir
    current_dir=$(pwd)
    # recursively look for `$MACRO_DIR_NAME/$macro_name`
    while true; do
        # check if the file exists and is executable
        if [ -x "$current_dir/$MACRO_DIR_NAME/$macro_name" ]; then
            echo "$current_dir/$MACRO_DIR_NAME/$macro_name"
            return 0
        fi
        if [ "$current_dir" = "/" ]; then
            break
        fi
        current_dir=$(dirname "$current_dir")
    done
    return 1
}

# TODO combine with resolve, or at least factor out the recursive search logic
list_macros() {
    local current_dir
    current_dir=$(pwd)
    local seen_names=()
    while true; do
        if [ -d "$current_dir/$MACRO_DIR_NAME" ]; then
            for macro_path in "$current_dir/$MACRO_DIR_NAME"/*; do
                macro_name=$(basename "$macro_path")
                if [ ! -x "$macro_path" ]; then
                    echo "[!] $macro_name (from $current_dir) is not executable"
                    continue
                fi
                # this will probably break if the macro name contains a space but why would you do that??
                if ! [[ "${seen_names[*]}" == *"$macro_name"* ]]; then
                    echo "    $macro_name (from $current_dir)"
                    seen_names+=("$macro_path")
                else
                    echo "[!] $macro_name (from $current_dir) is shadowed"
                fi
            done
        fi
        if [ "$current_dir" = "/" ]; then
            break
        fi
        current_dir=$(dirname "$current_dir")
    done
}

call_macro() {
    local macro_path=$1
    shift
    local call_dir
    call_dir=$(pwd)
    local macro_dir
    macro_dir=$(dirname "$(dirname "$macro_path")")
    local macro_name
    macro_name=$(basename "$macro_path")
    echo "calling $macro_name from $macro_dir" >&2
    env LM_CALL_DIR="$call_dir" LM_MACRO_DIR="$macro_dir" LM_MACRO="$macro_name" "$macro_path" "$@"
    return $?
}

ensure_macro_dir() {
    if [ ! -d "$MACRO_DIR_NAME" ]; then
        echo "Creating macro directory $MACRO_DIR_NAME in $(pwd)" >&2
        mkdir "$MACRO_DIR_NAME"
    fi
}

create_macro() {
    ensure_macro_dir

    local macro_name=$1
    local macro_path="$MACRO_DIR_NAME/$macro_name"

    touch "$macro_path"
    chmod +x "$macro_path"
    echo "Macro $macro_name created at $macro_path"
    if [ -n "$EDITOR" ]; then
        $EDITOR "$macro_path"
    fi
}

main() {
    case $1 in
        -l | --list)
            list_macros
            return 0
            ;;
        -r | --resolve)
            if [ -z "$2" ]; then
                echo "Macro name is required"
                return 1
            fi
            resolve "$2"
            return $?
            ;;
        -c | --create)
            if [ -z "$2" ]; then
                echo "Macro name is required"
                return 1
            fi
            create_macro "$2"
            return $?
            ;;
        -h | --help)
            help
            return 0
            ;;
        *)
            if [ -z "$1" ]; then
                list_macros
                return 0
            fi
            ;;
    esac

    local macro_path
    macro_path=$(resolve "$1")
    if [ -z "$macro_path" ]; then
        echo "Macro not found: $1"
        return 1
    fi
    shift
    call_macro "$macro_path" "$@"
}

main "$@"